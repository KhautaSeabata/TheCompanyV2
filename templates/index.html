<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deriv Volatility Indices Live Data</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
        }
        .chart-container {
            width: 100%;
            height: 400px; /* Increased height for better visibility */
            background-color: #2d3748; /* Darker background for charts */
            border-radius: 0.5rem; /* Rounded corners */
            overflow: hidden; /* Hide overflow */
        }
        .chart-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #cbd5e0;
        }
        .tab-button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            background-color: #4a5568;
            color: #e2e8f0;
            border: 1px solid transparent;
        }
        .tab-button.active {
            background-color: #63b3ed; /* Blue for active tab */
            color: #1a202c;
            border-color: #63b3ed;
        }
        .tab-button:hover:not(.active) {
            background-color: #5a6578;
        }
        /* Hide all chart wrappers by default, only show active one */
        .chart-wrapper {
            display: none;
        }
        .chart-wrapper.active {
            display: block;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <h1 class="text-3xl md:text-4xl font-bold text-center mb-8 text-blue-400">Deriv Volatility Indices Live Data</h1>

    <!-- Symbol Tabs -->
    <div class="flex flex-wrap justify-center gap-2 mb-4" id="symbol-tabs">
        <!-- Tabs will be dynamically generated here -->
    </div>

    <!-- Timeframe Tabs -->
    <div class="flex flex-wrap justify-center gap-2 mb-8" id="timeframe-tabs">
        <!-- Timeframe tabs will be dynamically generated here -->
    </div>

    <!-- Chart Container -->
    <div id="chart-section" class="p-4 bg-gray-800 rounded-lg shadow-lg">
        <h3 class="chart-title text-center text-xl mb-4" id="current-chart-title"></h3>
        <div id="main-chart-container" class="chart-container"></div>
    </div>

    <!-- Socket.IO Client Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.min.js"></script>
    <!-- Lightweight Charts Library -->
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.umd.production.js"></script>

    <script>
        const SYMBOLS = ["R_100", "R_75", "R_50", "R_25"];
        const INTERVALS = {
            'tick': 'Tick Data',
            '60': '1 Min Candles',
            '300': '5 Min Candles',
            '900': '15 Min Candles'
        };

        let currentChart = null; // Stores the single Lightweight Chart instance
        let currentSeries = null; // Stores the single series instance
        let chartDataStore = {}; // Stores all data: { 'symbol_interval': [] }

        let activeSymbol = SYMBOLS[0]; // Default active symbol
        let activeTimeframe = 'tick'; // Default active timeframe

        // Initialize Socket.IO connection
        const socket = io();

        // Function to create or update the main chart
        function initializeMainChart() {
            const container = document.getElementById('main-chart-container');
            if (!container) return;

            // Dispose of existing chart if it exists
            if (currentChart) {
                currentChart.remove();
            }

            currentChart = LightweightCharts.createChart(container, {
                width: container.clientWidth,
                height: container.clientHeight,
                layout: {
                    backgroundColor: '#2d3748',
                    textColor: '#cbd5e0',
                },
                grid: {
                    vertLines: {
                        color: '#4a5568',
                    },
                    horzLines: {
                        color: '#4a5568',
                    },
                },
                timeScale: {
                    timeVisible: true,
                    secondsVisible: true,
                    borderColor: '#4a5568',
                },
                priceScale: {
                    borderColor: '#4a5568',
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
            });

            // Add a line series for all data types (tick, 1min, 5min, 15min)
            currentSeries = currentChart.addLineSeries({
                color: '#63b3ed', // Blue for line chart
                lineWidth: 2,
            });

            // Handle window resize to make charts responsive
            new ResizeObserver(entries => {
                entries.forEach(entry => {
                    currentChart.applyOptions({ width: entry.contentRect.width, height: entry.contentRect.height });
                });
            }).observe(container);

            // Set initial data for the newly created chart
            const chartId = `${activeSymbol}_${activeTimeframe}`;
            if (chartDataStore[chartId]) {
                currentSeries.setData(chartDataStore[chartId]);
            }
        }

        // Function to update chart data
        function updateChart(symbol, interval, newData) {
            const chartId = `${symbol}_${interval}`;

            // Store the data
            if (!chartDataStore[chartId]) {
                chartDataStore[chartId] = [];
            }
            // For candlestick data, we only care about the close price for line chart
            const dataToStore = interval === 'tick' ? newData : { time: newData.time, value: newData.close };
            chartDataStore[chartId].push(dataToStore);

            // Keep a reasonable number of data points to prevent performance issues
            const maxDataPoints = 500; // Adjust as needed
            if (chartDataStore[chartId].length > maxDataPoints) {
                chartDataStore[chartId] = chartDataStore[chartId].slice(-maxDataPoints);
            }

            // If this is the currently active chart, update it
            if (symbol === activeSymbol && interval === activeTimeframe) {
                if (currentSeries) {
                    currentSeries.update(dataToStore);
                }
            }
        }

        // Function to set initial chart data
        function setInitialChartData(symbol, interval, data) {
            const chartId = `${symbol}_${interval}`;
            // For candlestick data, convert to line chart format (time, value)
            chartDataStore[chartId] = data.map(item =>
                interval === 'tick' ? item : { time: item.time, value: item.close }
            );

            // If this is the currently active chart, set its data
            if (symbol === activeSymbol && interval === activeTimeframe) {
                if (currentSeries) {
                    currentSeries.setData(chartDataStore[chartId]);
                }
            }
        }

        // --- UI Generation ---
        function generateSymbolTabs() {
            const tabContainer = document.getElementById('symbol-tabs');
            tabContainer.innerHTML = ''; // Clear existing tabs
            SYMBOLS.forEach(symbol => {
                const button = document.createElement('button');
                button.className = `tab-button ${symbol === activeSymbol ? 'active' : ''}`;
                button.textContent = symbol.replace('R_', 'Volatility ');
                button.onclick = () => switchSymbol(symbol);
                tabContainer.appendChild(button);
            });
        }

        function generateTimeframeTabs() {
            const tabContainer = document.getElementById('timeframe-tabs');
            tabContainer.innerHTML = ''; // Clear existing tabs
            Object.keys(INTERVALS).forEach(intervalKey => {
                const button = document.createElement('button');
                button.className = `tab-button ${intervalKey === activeTimeframe ? 'active' : ''}`;
                button.textContent = INTERVALS[intervalKey];
                button.onclick = () => switchTimeframe(intervalKey);
                tabContainer.appendChild(button);
            });
        }

        function updateChartTitle() {
            const titleElement = document.getElementById('current-chart-title');
            const symbolText = activeSymbol.replace('R_', 'Volatility ');
            const timeframeText = INTERVALS[activeTimeframe];
            titleElement.textContent = `${symbolText} - ${timeframeText}`;
        }

        function switchSymbol(symbol) {
            if (activeSymbol === symbol) return;
            activeSymbol = symbol;
            generateSymbolTabs(); // Re-render symbol tabs to update active state
            updateChartDisplay();
        }

        function switchTimeframe(timeframe) {
            if (activeTimeframe === timeframe) return;
            activeTimeframe = timeframe;
            generateTimeframeTabs(); // Re-render timeframe tabs to update active state
            updateChartDisplay();
        }

        function updateChartDisplay() {
            updateChartTitle();
            initializeMainChart(); // Re-initialize the chart with new symbol/timeframe
        }

        // --- Socket.IO Event Handlers ---
        socket.on('connect', () => {
            console.log('Connected to Flask Socket.IO');
            // Request initial data after connection (if needed, though server sends on connect)
        });

        socket.on('initial_tick_data', (msg) => {
            setInitialChartData(msg.symbol, 'tick', msg.data);
        });

        socket.on('initial_candlestick_data', (msg) => {
            setInitialChartData(msg.symbol, msg.interval, msg.data);
        });

        socket.on('tick_update', (msg) => {
            updateChart(msg.symbol, 'tick', msg.data);
        });

        socket.on('candlestick_update', (msg) => {
            updateChart(msg.symbol, msg.interval, msg.data);
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from Flask Socket.IO');
        });

        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            generateSymbolTabs();
            generateTimeframeTabs();
            updateChartDisplay(); // Initialize the first chart
        });
    </script>
</body>
</html>
