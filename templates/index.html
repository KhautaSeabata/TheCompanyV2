import json
import time
import requests
from datetime import datetime
from flask import Flask, render_template, jsonify, request
from flask_cors import CORS
import logging

app = Flask(__name__)
CORS(app)

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Firebase Realtime Database URL
FIREBASE_URL = "https://fir-8908c-default-rtdb.firebaseio.com"

class FirebaseVIXDataManager:
    def __init__(self):
        self.cache = {
            'ticks': [],
            '1min_candles': [],
            '5min_candles': [],
            'last_fetch': None
        }
        
    def fetch_firebase_data(self):
        """Fetch data from Firebase and return structured data"""
        try:
            # Fetch ticks data
            ticks_url = f"{FIREBASE_URL}/ticks.json"
            ticks_response = requests.get(ticks_url, timeout=10)
            
            # Fetch 1min candles
            candles_1min_url = f"{FIREBASE_URL}/1minVix25.json"
            candles_1min_response = requests.get(candles_1min_url, timeout=10)
            
            # Fetch 5min candles  
            candles_5min_url = f"{FIREBASE_URL}/5minVix25.json"
            candles_5min_response = requests.get(candles_5min_url, timeout=10)
            
            # Process ticks data
            ticks_data = []
            if ticks_response.status_code == 200 and ticks_response.json():
                raw_ticks = ticks_response.json()
                # Get R_25 data from ticks
                if 'R_25' in raw_ticks:
                    r25_data = raw_ticks['R_25']
                    # Convert to list and sort by epoch
                    tick_list = []
                    for key, tick in r25_data.items():
                        if isinstance(tick, dict) and 'epoch' in tick and 'quote' in tick:
                            tick_list.append({
                                'price': float(tick['quote']),
                                'timestamp': datetime.fromtimestamp(tick['epoch']).isoformat(),
                                'epoch': tick['epoch'],
                                'symbol': tick.get('symbol', 'R_25')
                            })
                    
                    # Sort by epoch and get latest 100
                    tick_list.sort(key=lambda x: x['epoch'], reverse=True)
                    ticks_data = tick_list[:100]
            
            # Process 1min candles
            candles_1min_data = []
            if candles_1min_response.status_code == 200 and candles_1min_response.json():
                raw_candles = candles_1min_response.json()
                candle_list = []
                for key, candle in raw_candles.items():
                    if isinstance(candle, dict) and all(k in candle for k in ['open', 'high', 'low', 'close', 'epoch']):
                        candle_list.append({
                            'timestamp': datetime.fromtimestamp(candle['epoch']).isoformat(),
                            'open': float(candle['open']),
                            'high': float(candle['high']),
                            'low': float(candle['low']),
                            'close': float(candle['close']),
                            'epoch': candle['epoch']
                        })
                
                # Sort by epoch and get latest 100
                candle_list.sort(key=lambda x: x['epoch'], reverse=True)
                candles_1min_data = candle_list[:100]
            
            # Process 5min candles
            candles_5min_data = []
            if candles_5min_response.status_code == 200 and candles_5min_response.json():
                raw_candles = candles_5min_response.json()
                candle_list = []
                for key, candle in raw_candles.items():
                    if isinstance(candle, dict) and all(k in candle for k in ['open', 'high', 'low', 'close', 'epoch']):
                        candle_list.append({
                            'timestamp': datetime.fromtimestamp(candle['epoch']).isoformat(),
                            'open': float(candle['open']),
                            'high': float(candle['high']),
                            'low': float(candle['low']),
                            'close': float(candle['close']),
                            'epoch': candle['epoch']
                        })
                
                # Sort by epoch and get latest 100
                candle_list.sort(key=lambda x: x['epoch'], reverse=True)
                candles_5min_data = candle_list[:100]
            
            # Update cache
            self.cache = {
                'ticks': ticks_data,
                '1min_candles': candles_1min_data,
                '5min_candles': candles_5min_data,
                'last_fetch': datetime.now().isoformat()
            }
            
            logger.info(f"Fetched {len(ticks_data)} ticks, {len(candles_1min_data)} 1min candles, {len(candles_5min_data)} 5min candles")
            
            return self.get_formatted_data()
            
        except Exception as e:
            logger.error(f"Firebase fetch error: {e}")
            return None
    
    def get_formatted_data(self):
        """Return formatted data for frontend"""
        current_price = 0
        last_update = None
        
        # Get current price from latest tick
        if self.cache['ticks']:
            current_price = self.cache['ticks'][0]['price']
            last_update = self.cache['ticks'][0]['timestamp']
        
        return {
            'symbol': 'R_25',
            'name': 'Volatility 10 (1s) Index',
            'live_ticks': list(reversed(self.cache['ticks'])),  # Reverse to show chronological order
            'candles_1min': list(reversed(self.cache['1min_candles'])),
            'candles_5min': list(reversed(self.cache['5min_candles'])),
            'current_price': current_price,
            'last_update': last_update,
            'total_ticks': len(self.cache['ticks']),
            'total_1min_candles': len(self.cache['1min_candles']),
            'total_5min_candles': len(self.cache['5min_candles']),
            'data_source': 'firebase',
            'last_fetch': self.cache['last_fetch']
        }

# Initialize data manager
data_manager = FirebaseVIXDataManager()

@app.route('/')
def index():
    """Serve the main HTML page"""
    return render_template('index.html')

@app.route('/api/data')
def get_data():
    """Get current data from Firebase"""
    data = data_manager.fetch_firebase_data()
    if data:
        return jsonify(data)
    else:
        return jsonify({'error': 'Failed to fetch Firebase data'}), 500

@app.route('/api/refresh')
def refresh_data():
    """Manually refresh data from Firebase"""
    try:
        data = data_manager.fetch_firebase_data()
        if data:
            return jsonify({
                'success': True,
                'data': data,
                'refreshed_at': datetime.now().isoformat()
            })
        else:
            return jsonify({'success': False, 'error': 'Failed to fetch data'}), 500
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/stats')
def get_stats():
    """Get basic statistics"""
    try:
        if not data_manager.cache['ticks']:
            data_manager.fetch_firebase_data()
        
        stats = {
            'total_ticks': len(data_manager.cache['ticks']),
            'total_1min_candles': len(data_manager.cache['1min_candles']),
            'total_5min_candles': len(data_manager.cache['5min_candles']),
            'last_fetch': data_manager.cache['last_fetch'],
            'firebase_url': FIREBASE_URL
        }
        
        # Calculate price statistics if we have tick data
        if data_manager.cache['ticks']:
            prices = [tick['price'] for tick in data_manager.cache['ticks']]
            stats.update({
                'current_price': prices[0] if prices else 0,
                'min_price': min(prices),
                'max_price': max(prices),
                'avg_price': sum(prices) / len(prices)
            })
        
        return jsonify(stats)
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    logger.info("Starting Firebase VIX Data Dashboard...")
    logger.info(f"Firebase URL: {FIREBASE_URL}")
    logger.info("Fetching initial data...")
    
    # Fetch initial data
    initial_data = data_manager.fetch_firebase_data()
    if initial_data:
        logger.info("Initial data fetch successful")
    else:
        logger.warning("Initial data fetch failed")
    
    logger.info("Server starting on port 5000...")
    app.run(host='0.0.0.0', port=5000, debug=True)
